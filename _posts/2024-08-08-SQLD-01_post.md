---
title: SQLD 01
date: 2024-08-05 20:00:00 +09:00
categories: [SQLD]
tags: [sqld, sql, cs]     # TAG names should always be lowercase
---


## 1-1 데이터 모델의 이해 

**모델링의 개념**
- 현실 세계의 비즈니스 프로세스와 데이터 요구 사항을 추상적이고 구조화된 형태로 표현하는 과정을 말한다.
- 데이터 베이스의 구조와 관계를 정의하며, 이를 통해 데이터의 저장, 조작, 관리 방법을 명확하게 정의한다.

즉, 모델링이란 현실 세계의 데이터를 추상적이고 구조화된 형태로 표현하는 과정이다.

<br>

**모델링의 3가지 관점** 
- 데이터 관점 : 업무와 데이터 또는 데이터 간의 관련성을 중점으로 하는 관점입니다.
- 프로세스 관점 : 실제 업무는 무엇이며, 수행해야 할 작업은 무엇인지에 중점을 둡니다.
- 데이터와 프로세스 관점 : 작업 방법에 따라 데이터가 어떤 영향을 받는지를 분석하는 관점입니다.

<br>

**모델링의 특징 (단순화, 추상화, 명확화)**
1. 단순화 (Simplification)  
    - 현실을 단순화하여 핵심 요소에 집중하고 **불필요한 세부 사항을 제거한다.**  
    - 단순화를 통해 복잡한 현실 세계를 이해하고 표현하기 쉬워진다.  
단순화란 현실을 단순화하여 핵심 요소에 집중하고 불필요한 세부사항을 제거하여 복잡한 현실 세계를 이해하고 표현하기 쉽게 만들어준다.  

1. 추상화 (Abstraction)  
    - 현실세계를 일정한 형식에 맞추어 **간략하게 대략적으로 표현하는 과정이다.**  
    - 다양한 현상을 일정한 양식인 표기법에 따라 표현한다.  
추상화란 현실 세계를 일정한 형식에 맞추어 간략하고 대략적으로 표현하는 과정으로 다양한 현상을 일정한 표기법에 따라 표현한다.  

1. 명확화 (Clarity)  
    - 대상에 대한 애매모호함을 최대한 **제거하고 정확하게 현상을 기술하는 과정이다.**  
    - 명확화를 통해 모델을 이해하는 이들의 의사소통을 원활히 수행한다.  
명확화는 대상에 대한 애매모함을 제거하고 정확하게 현상을 기술화는 과정으로 모델을 이해하는 이들의 의사소통을 도운다.  

<br>

**데이터 모델링 유의점 (중복, 비유연성, 비일관성)**  
1. 중복 (Duplication)  
    - 한 테이블 또는 여러 테이블에 같은 정보를 저장하지 않도록 설계  

2. 비유연성 (Inflexibility)  
    - 사소한 업무 변화에 대해서도 잦은 모델 변경이 되지 않도록 주의  
    - 데이터 정의를 프로세스와 분리  

3. 비일관성 (Inconsistency)  
    - 데이터베이스 내의 정보가 모순되거나 상반된 내용을 갖는 상태를 의미  
    - 데이터간 상호연관 관계를 명확히 정의  
    - 데이터 품질 관리가 필요  
    - 데이터의 중복이 없더라도 비일관성은 발생할 수 있음  

<br>

**데이터 모델링 3가지 요소 (대상, 속성, 관계)**  
- 대상 (Entitiy) : 업무가 관리하고자 하는 대상 (객체)  
- 속성 (Attribute) : 대상들이 갖는 속성 (하나의 특징으로 정의될 수 있는 것)  
- 관계 (Relationship) : 대상들의 관계

<br>

**데이터 모델링의 3 단계 (개념적 모델링 - 논리적 모델링 - 물리적 모델링)**  

1. 개념적 모델링 
- 업무 중심적이고 포괄적(전사적)인 수준의 모델링
- 추상화 수준이 가장 높음
- 업무를 분석한 후 업무의 핵심 엔티티를 추출하는 단계
- 도출된 핵심 엔티티들과의 관계들을 표현하기 위해 ERD 작성

> **정리 :** 개념적 모델링은 업무를 분석한 후 핵심 엔티티를 추출하는 단계, ERD, 추상화 수준이 가장 높은 단계.

<br>

1. 논리적 모델링
- 개념적 모델링의 결과를 토대로 세부속성, 식별자, 관계 등을 표현하는 단계
- 데이터 구조를 정의하기 때문에 비슷한 업무나 프로젝트에서 동일한 형태의 데이터 사용 시 재사용 가능
- 동일한 논리적 모델을 사용하는 경우 쿼리도 재사용 가능
- 데이터 정규화 수행
- 재사용성이 높은 논리적 모델은 유지보수가 용이해짐

> **정리 :** 논리적 모델링은 개념적 모델링의 결과를 토대로 세부속성, 식별자, 관계 등을 표현하고 데이터 정규화를 수행하는 단계

<br>

1. 물리적 모델링
- 논리 모델링이 끝나면 이를 직접 물리적으로 생성하는 과정
- 데이터베이스 성능, 디스크 저장구조, 하드웨어의 보완성, 가용성 등을 고려
- 가장 구체적인 데이터 모델링
- 추상화 수준은 가장 낮음 (가장 구체적인 모델링)

> **정리 :** 물리적 모델링은 논리 모델링이 끝난 후 직접 물리적으로 생성하는 과정으로 성능, 저장구조, 보완성, 가용성을 고려하는 단계

<br>

**데이터 모델의 표기법 (ERD : Entitiy Relationship Diagraim)**
- **엔티티(Entitiy)와 엔티티 간의 관계(Relationship)를 시각적으로 표현한 다이아그램**  
- 1976년 피터 첸(Peter Chen)이 만든 표기법, 데이터 모델링 표준으로 사용  

<br>

**ERD 작성 절차**
  1. 엔티티 도출 후 그린다.  
  2. 엔티티 배치  
  3. 엔티티 간의 관계를 설정  
  4. 관계명을 서술  
  5. 관계의 참여도 기술  
  6. 관계의 필수 여부를 확인  

<br>
<br>

## 1-2 엔티티 

**엔티티(Entity)의 개념** 
- 현실 세계에서 독립적으로 식별 가능한 객체나 사물을 나타냄  
- 엔티티는 업무상 분석해야 하는 대상(Instance)들로 이루어진 집합을 의미  
- 인스턴스는 엔티티의 특정한 속성 값들로 구성되며, 엔티티의 개념을 현실에서 구체적으로 나타낸 것  
- Ex. 엔티티와 속성, 인스턴스 등의 관계

- 엔티티 (Entity) : 학생
- 속성 (Attribute) : 학번, 이름, 학과 등.
- 식별자 (Idenrifier) : 학번 (고유한 학번으로 각 학생을 식별)
- 인스턴스 : 특정 학생의 데이터
    - 학번 : 20210001
    - 이름 : 홍길동
    - 학과 : 컴퓨터 공학

<br>

**엔티티의 특징**
1. 유일한 식별자에 의해 식별 가능
   - 인스턴스가 식별자에 의해 한 개씩만 존재하는 지 검증 필요
   - 유일한 식별자는 그 엔티티의 인스턴스만의 고유 이름

2. 해당 업무에 필요하고 관리하고자 하는 정보
   - 설계하는 업무의 시스템 구축에 필요한 정보여야 함 
   - Ex. 학교 시스템 구축 시 학생정보 필요. 다른 업무엔 학생 정보 불필요.

3. 인스턴스들의 집합
    - 영속적으로 존재하는 2개 이상의 인스턴스의 집합
    - 인스턴스가 한 개 밖에 없는 엔티티는 집합이 아니므로 성립이 안됨

4. 엔티티는 반드시 속성을 가짐
    - 각 엔티티는 2개 이상의 속성을 가짐
    - 하나의 인스턴스는 각각의 속성들에 대한 1개의 속성 값만을 가짐
    - Ex. 학생 엔티티에서 한 학생의 데이터(인스턴스)의 이름(속성) 정보에는 반드시 한 값만 저장됨

5. 엔티티는 업무 프로세스에 의해 이용
    - 업무적으로 필요해 선정했지만 실제 사용되지 않으면 잘못 설계된 것
    - 모델링 시 발견하기 어려운 경우 데이터 모델 검증이나 상관 모델링 시 단위 프로세스 교차점검으로 문제 도출
    - 누락된 프로세스의 경우 추후 해당 프로세스 추가
    - 반대로 사용되지 않는 고립 엔티티는 제거 필요

6. 다른 엔티티와 최소 1개 이상의 관계 성립
    - 엔티티는 업무적 연관성을 갖고 다른 엔티티와 연관의 의미를 가짐
    - 관계가 없는 엔티티 도출은 부적절한 엔티티이거나 적절한 관계를 찾지 못한것

<br>

**엔티티의 분류**

1) **유형과 무형에 따른 분류**
   
 1. 유형 엔티티 
     - 물리적 형태가 있음 (실체가 있는 대상)
     - 안정적이며 지속적으로 활용되는 엔티티 
     - 업무롭퉈 구분하기가 가장 용이한 엔티티
     - Ex. 사원, 물품, 감사 등

 2. 개념 엔티티 
     - 물리적인 형태가 없음
     - 관리해야 할 개념적 정보로부터 구분되는 엔티티
     - Ex. 조직, 보험상품 등

 3. 사건 엔티티
     - 업무를 수행에 따라 발생하는 엔티티
     - 발생량이 많고 각종 통계자료에 이용
     - Ex. 주문, 청구 미납 등

<br>

2) **발생 시점에 따른 분류**
   
 1. 기본 엔티티 
     - 그 업무에 원래 존재하는 정보
     - 다른 엔티티와 관계에 의해 생서되지 않고 독립적으로 생성
     - 타 엔티티의 부모 역할을 하는 엔티티
     - 다른 엔티티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가짐
     - Ex. 사원, 부서, 고객, 상품 등

 2. 중심 엔티티
     - 기본 엔티티로부터 발생되고 그 업무에서 줌싱적인 역할
     - 많은 데이터가 발생되고 다른 엔티티와의 관계를 통해 많은 행위 엔티티를 생성
     - Ex. 계약, 사고, 청구, 주문, 매출 등

 3. 행위 엔티티 
     - 2개 이상의 부모 엔티티로부터 발생
     - 자주 내용이 바뀌거나 데이터 양이 증가
     - 분석 초기 단계보다는 상세 설꼐 단계나 프로세스와 상관 모델링을 진행하면서 도출
     - Ex. 주문 (고객과 상품 엔티티로 부터 발생하므로 행위 엔티티이기도 함), 사원변경이력, 이력 등

<br>

**엔티티의 명명**
1. 현업에서 사용하는 용어 사용
2. 가능하면 약자 사용은 자제
3. 단수 명사 사용
4. 모든 엔티티에서 유일하게 이름 부여
5. 엔티티 생성 의미대로 이름 부여

<br>
<br>

## 1-3 속성

**속성(Attribute)의 개념**
- 속성은 업무에서 필요로 하는 고유한 성질, 특징을 의미 (관찰 대상) -> 컬럼으로 표현할 수 있는 단위
- 업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소의 데이터 단위
- 인스턴스의 구성 요소  
    - Ex. 학생 엔티티에 이름, 학번, 학과번호 등이 속성이 될 수 있음

<br>

**엔티티, 인스턴스, 속성, 속성값의 관계**
- **한 개의 엔티티는 2개 이상의 인스턴스의 집합이어야 한다.** (하나의 테이블은 두 개 이상의 행을 가짐)
- **한 개의 엔티티는 2개 이상의 속성을 갖는다.** (하나의 테이블은 두 개 이상의 컬럼으로 구성됨)
- **한 개의 속성은 1개의 속성 값을 갖는다.** (각 컬럼의 값은 하나씩만 삽입 가능)
- 속성은 엔티티에 속한 엔티티에 대해 자세하고 구체적인 정보를 나타낸다. **각 속성은 구체적인 값을 가진다.**

<br>

**속성의 특징**
- 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다.
- **정해진 주식별자에 함수적 종속성을 가져야 한다.**
- **하나의 속성은 한개의 값만을 가진다.** (한 컬럼의 값은 각 인스턴스마다 하나씩만 저장)
- 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔티티를 이용하여 분리한다.
- 하나의 인스턴스는 속성마다 반드시 하나의 속성값을 가진다.  
- 속성이란 각 속성이 하나의 값을 갖고 있음을 의미 (속성의 원자값)

<br>

**원자성 이란?**
- 데이터 모델에서 각 엔티티의 인스턴스가 해당 속성에 대해 단일하고 명확한 값을 가지는 것을 의미한다.

<br>

**함수적 종속성**
- 한 속성의 값이 다른 속성의 값에 종속적인 관계를 갖는 특징을 말한다.
- 즉, 어떤 속성 A의 값에 의해 다른 속성 B도 유일하게 결정된다면, B는 A에 함수적으로 종속됐다고 한다.
- 이를 수식으로 나타내면 A -> B 라고 표현한다.

    1) 완전 함수적 종속
    - 특정 컬럼이 기본키에 대해 완전히 종속될 때를 말함
    - PK를 구성하는 컬럼이 2개 이상일 경우 PK 값 모두에 의한 종속관계를 나타날 때 완전 함수 종속성을 만족.
    - Ex. (주문번호 + 제품번호)에 의해 수량 컬럼의 값이 결정됨

    | 주문번호 | 제품번호 | 수량 |
    | -------- | -------- | ---- |
    | 1        | A123     | 10   |
    | 2        | B456     | 5    |
    | 3        | C789     | 12   |

    <br>

    2) 부분 함수적 종속
    - 기본키 전체가 아니라, 기본키 일부에 대해 종속될 때를 말함
    - Ex. 수강기록 테이블에서 학생번호와 과목이 PK라고 가정할 때, 과목에 의해서도 교수가 결정되면 부분 함수정 종속 관계

    | 학생번호 (학번) | 과목 | 교수   | 점수 |
    | --------------- | ---- | ------ | ---- |
    | 101             | 수학 | 김교수 | 85   |
    | 101             | 영어 | 이교수 | 90   |
    | 102             | 수학 | 김교수 | 88   |
    | 103             | 과학 | 박교수 | 92   |
    | 104             | 영어 | 이교수 | 87   |

<br>
<br>

**속성의 분류**

1) **속성의 특성에 따른 분류**
 2. 기본 속성
     - 업무로부터 추출된 모든 속성
     - 엔티티에 가장 일반적으로 많이 존재하는 속성
     - Ex. 원금, 예치기간 등 
    
 3. 설계 속성
     - 기본 속성 외에 업무를 규칙화하기 위해 새로 만들어지거나 기본 속성을 변형하여 만들어지는 속성
     - Ex. 상품코드, 지점코드, 예금분류 등
       
 4. 파생 속성
     - 다른 속성에 의해 만들어지는 속성
     - 일반적으로 계산된 값들이 해당
     - 데이터 정합성을 유지하기 위해 가급적 적게 정의하는 것이 좋음
     - Ex. 합계, 평균, 이자 등
       
<br>

2) **엔티티 구성방식에 따른 분류**
 1. PK (Primary Key, 기본키)
    - 인스턴스를 식별할 수 있는 속성
 2. FK (Foreign Key, 외래키)
    - 다른 엔티티와의 관계에서 포함된 속성
 3. 일반 속성 
    - 엔티티에 포함되어 있고 PK/FK에 포함되지 않는 속성
    
<br>

3) **분해 여부에 따른 속성**
 1. 단일 속성
    - 하나의 의미로 구성된 경우
    - Ex. 회원ID, 이름 등
      
 2. 복합 속성
    - 여러개의 의미로 구성된 경우
    - Ex. 주소 (시, 구, 동, 등으로 분해 가능) 등
    
 3. 다중값 속성
    - 속성에 여러 개의 값을 가질 수 있는 경우
    - 다중값 속성은 엔티티로 분해
    - Ex. 상품 리스트 등

<br>

**속성의 명명 규칙**
1. 해당 업무에서 사용하는 이름을 부여
2. 서술식 속성명은 사용하지 않음
3. 약어의 사용은 가급적 제한
4. 전체 데이터 모델에서 유일한 명칭

<br>

**도메인 (Domain)**
- 도메인은 각 속성이 가질 수 있는 값의 범위를 의미함
- 엔티티 내에서 속성에 대한 데이터 타입과 크기, 제약사항을 지정하는 것이다.

<br>
<br>

## 1-4 관계

**관계 (Relationship)의 개념**
- **관계는 엔티티간의 연관성을 나태낸 개념**
- 관계를 정의할 때는 인스턴스(각 행 데이터)간의 논리적인 연관성을 파악하여 정의
- 엔티티를 어떻게 정의하느냐에 따라 변경되기도 함

<br>

**관계의 종류**
1) 존재적 관계
    - 한 엔티티의 존재가 다른 엔티티의 존재에 영향을 미치는 관계
    - 엔티티 간의 연관된 상태를 의미
    - Ex. 부서 엔티티가 삭제되면 사원 엔티티의 존재에 영향을 미침

<br>

2) 행위적 관계
    - 엔티티 간의 어떤 행위가 있는 것을 의미
    - Ex. 고객 엔티티의 행동에 의한 주문 엔티티가 발생


> **Tip:** ERD에서 존재관계와 행위관계를 구분하지 않는다.

<br>

**관계의 구성**
1. 관계명
2. 차수 (Cardinality)
3. 선택성 (Optionality)

<br>

**관계의 차수 (Cardinality)**
- 한 엔티티의 레코드(인스턴스)가 다른 엔티티의 레코드(인스턴스)와 어떻게 연결되는지를 나타내는 표현
- 주로 1:1, 1:N, N:M 등으로 표현

<br>

1) 1:1 관계
- 완전 1:1 관계
  - 하나의 엔티티에 관계뙤는 엔티티가 반드시 하나로 존재하는 경우
  - Ex. 사원은 반드시 소속 부서가 있어야 함

- 선택적 1:1 관계
  - 하나의 엔티티에 관계되는 엔티티가 하나이거나 없을 수 있는 경우
  - Ex, 사원은 하나의 소속 부서가 있거나 아직 발령전이면 없을 수 있음

<br>

2) 1:N 관계
- 엔티티에 하나의 행에 다른 엔티티의 값이 여러 개 있는 관계
- Ex. 고객은 여러개 계좌를 소유할 수 있음

<br>

3) N:M 관계
- 두 엔티티가 다대다의 연결 관계 가지고 있음
- 이 경우 조인 시 카테시안 곱이 발생하므로 두 엔티티를 연결하는 연결에티티의 추가로 1:N 관계로 해소할 필요가 있음
- Ex. 한 학생이 여러 강의를 수강할 수 있고, 한 강의 기준으로도 여러 학생이 보유할 수 있음 
  - 이 두 엔티티의 연결 엔티티로 구매이력 엔티티가 필요함

<br>
**관계의 페어링**
- 엔티티 안에 인스턴스가 개별적으로 관계를 가지는 것
- 관계란 페어링의 집합을 의미함

<br>

**관계와 차수, 페어링 차이**
- 학생과 강의 엔티티는 관계를 가짐
- 한 학생은 여러 강의를 수강할 수 있고, 한 강의도 여러 학생에게 수강될 수 있으므로 N:M 관계이며, 이때 차수는 N:M
- 인스턴스의 관계를 보면 "학생 A가 강의 B를 2023년 1학기에 수강했고 성적은 'A+'를 받았다"와 같은 특정한 페어링이 형성
- 관계의 차수는 하나의 엔티티와 다른 엔티티 간의 레코드 연결방식을 나태나는 냄
- 관계의 페어링은 두엔티티간의 특정 연결을 설명하고 추가 정보를 제공하는 용도로 사용

<br>
<br>

## 1-5 식별자

**식별자의 개념**
- 하나의 엔티티에 구성된 여러 개의 속성 중에 **엔티티를 대표할 수 있는 속성**을 나타냄
- **하나의 유일한 식별자**가 존재해야 함
- 식별자는 논리 모델링에서 사용하는 용어이고, 물리 모델링에서는 키(key)라고 표현한다.
- Ex. [논리 모델링] 학생 엔티티의 주식별자는 학생번호 속성 => [물리 모델링] 학생테이블의 기본키는 학생버호 컬럼

<br>

**주식별자 특징**
1) **유일성** : 주식별자에 의해 모든 인스턴스를 유일하게 구분함
2) **최소성** : 주식별자를 구성하는 속성은 유일성을 만족하는 최소한의 속성으로 구성
3) **불변성** : 주식별자가 한번 특정 엔티티에 지정되면 그 식발져의 값은 변하지 않아야 함
4) **존재성** : 주식별자가 지정되면 반드시 값이 존재해야 하며 NULL은 허용하지 않음

<br>

**식별자 분류**  

1) **대표성 여부에 따른 식별자의 종류**
- 주식별자
  - **유일성과 최소성을 만족하면서 엔티티를 대표하는 식별자**
  - 엔티티 내에서 각 인스턴스를 유일하게 구분할 수 있는 식별자
  - 타 엔티티와 참조관계를 연결할 수 있는 식별자

- 보조 식별자
  - 엔티티 내에서 각 인스턴스를 구분할 수 있는 구분자지만, 대표성을 가지지 못해 참조 관계 연결을 할 수 없는 식별자
  - 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자

<br>

1) **생성 여부에 따른 식별자의 종류**
- 내부 식별자
  - 다른 엔티티 참조 없이 엔티티 내부에서 스스로 생성되는 식별자
  
- 외부 식별자
  - 다른 엔티티와 관계로 인하여 만들어지는 식별자 (외래키)

<br>

3) **속성 수에 따른 식별자 종류**
- 단일 식별자
  - 하나의 속성으로 구성

- 복합 식별자
  - 2개 이상의 속성으로 구성
  
<br>

4) **대체 여부에 따른 식별자의 종류**
- 본질 식별자
  - 비즈니스 프로세스에서 만들어지는 식별자

- 인조 식별자
  - 인위적으로 만들어지는 식별자
  - 자동 증가하는 일련번호 같은 형태

<br>

**주식별자 도출 기준**  
1) 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
- 같은 식별자 족너을 만족하더라도 업무적으로 더 많이 사용되는 속성을 주식별자로 지정
- Ex. 학생번호와 주민번호 중에 학생번호가 주식별자, 주민번호는 보조식별자


2) 명칭이나 내역등과 같은 이름은 피함
- 이름 자체를 주식별자로 사용하는 행위를 피함
- Ex. 부서명 보다는 부서코드를 부여하여 부서코드로 주식별자로 사용


3) 속성의 수를 최대한 적게 구성
- 주식별자를 너무 많은 속성으로 구성 시, 조인으로 인한 성능저하 발생 우려
- 일반적으로 7 ~ 8개 이상의  주식별자 구성은 새로운 인조식별자를 생성하여 모델을 단순화 시키는 것이 좋음
- Ex. 주문 엔티티에 대해 주문일자 + 주문상품코드 + 고객번호 + ... 등으로 구성 => 주문번호 속성 추가


<br>

**관계간 엔티티 구분**

1) 강한 개체
- 독립적으로 존재할 수 있는 엔티티
- Ex. 고객과 계좌 엔티티 중, 고객은 독립적으로 존재할 수 있음
<br>

1) 약한 개체
- 독립적으로 존재할 수 없는 엔티티
- Ex. 고개과 계좌 엔티티 중, 계좌는 독립적으로 존재할 수 없음 (고객에 의해 파생되는 엔티티)

<br>

**식별관계와 비식별관계**
1) 식별관계 (Identification Relationship)
- 하나의 엔티티의 기본키를 다른 엔티티가 기본키의 하나로 공유하는 관계
- 식별관계는 ERD에서 실선으로 표시
- Ex. 사원과 교육이력 엔티티에서 양쪽 모두 기본키 중 일부가 사원번호임
- 사원 # 사원번호  / 교육이력 # 사원번호 (FK) # 수강일자

<br>

1) 비식별관계 (Non-Identification Relationship)
- 강한 개체의 기본키를 다른 엔티티의 기본키가 아닌 일반 속성으로 관계를 가지는 것
- 비식별관계는 ERD에서 점선으로 표시
- Ex. 부서와 사원의 관계에서 부서의 부서번호(키본키)를 사원 엔티티에서는 일반키로 가짐 (사원에서는 사원번호가 기본키)

<br>
<br>

## 1-6 정규화


**정규화의 개념(DB Normalization)의 개념**
- 하나의 엔티티에 많은 속성을 넣게 되면, 해당 엔티티를 조회할 때 마다 많은 양의 데이터가 조회될 것이므로 **최소한의 데이터만을 하나의 엔티티에 넣는 식으로 데이터를 분해하는 과정**을 정규화라고 한다.
- 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 과정이라고 볼수 있다.
- **데이터의 중복을 제거하고 데이터 모델의 독립성을 확보** 
- **데이터 이상현상을 줄이기 위한** 데이터 베이스 걸계 기법
- 엔티티를 상세화하는 과정으로 **논리 데이터 모델링 수행 시점**에서 고려됨
- 제 1 정규화부터 제 5 정규화까지 존재, 실질적으로는 제 3 정규화까지만 수행

<br>

**이상현상 (Abnormality)**
- **정규화를 하지 않아 발생하는 현상(삽입이상, 갱신이상, 삭제이상)**
- 특정 인스턴스가 삽입 될때 정의되지 않아도 될 속성까지도 반드시 입력되어야 하는(삽입이상) 현상이 발생함
- 불필요 한 값까지 입력해야 되는 현상을 삽입이상, 그 외 갱신이상, 삭제이상이 발생할 수 있음
- Ex. 부서 정보만 삭제하면 되는데 관련된 사원 정보까지 함게 삭제되는 현상(삭제이상)

<br>

**정규화 단계** 
1. **제 1 정규화 (1NF)**
- 1NF는 테이블의 각 컬럼이 더 이상 분해할 수 없는 단일 값(원자값, Atomic Value)을 갖도록 테이블을 분해하는 단계
- 쉽게 말해 하나의 행과 컬럼의 값이 반드시 한 값만 입력되도록 행을 분리하는 단계

<br>


2. **제 2 정구화 (2NF)**
- 제 1정규화를 진행한 테이블에 대해 완전 함수 종속을 만들도록 테이블을 분해
- 완전 함수 종속이란, 기본키를 구성하는 모든 컬럼의 값이 다른 컬럼을 결정짓는 상태
- 기본키의 부분 집합이 다른 컬럼과 1:1 대응 관계를 갖지 않는 상태를 의미
- 즉, PK(Primary Key)가 2개 이상일 때 발생하며 PK의 일부와 종속되는 관계가 있다면 분리한다.

<br>

3. **제 3 정규화 (3NF)**
- 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분리
- 이행적 종속이란 A -> B, B -> C 의 관계가 성립할 때, A -> C 가 성립되는 것을 말함

<br>


4. **BCNF (Boyce-Codd Normal Form) 정규화**
- 모든 결정자가 후보키가 되도록 테이블을 분해하는 것 (결정자가 후보키가 아닌 다른 컬럼에 종속되면 안됨)

<br>


5. **제 4 정규화**
- 여러 컬럼들이 하나의 컬럼을 종속시키는 경우 분해하여 다중값 종속성을 제거

<br>


6. **제 5 정규화**
- 조인에 의해서 종속성이 발생되는 경우 분해

<br>


**반정규화 = 역정규화 (De-Normalization)의 개념**
- 데이터베이스의 성능 향상을 위한 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법
- 시스템의 성능 향상, 개발 및 운영의 단순화를 위해 정규화된 데이터 모델을 중복, 통합, 분리하는 데이터 모델링 기법
- 조회(SELECT) 속도를 향상시키지만, 데이터 모델의 유연성은 낮아짐

<br>


**반정규화 수행 케이스**
- 정규화에 충실하여 종속성, 활용성은 향상되지만, 수행 속도가 느려지는 경우 
- 다량의 범위를 자주 처리해야 하는 경우
- 특정 범위의 데이터만 자주 처리하는 경우
- 요약/집계 정보가 자주 요구되는 경우


정규화에 대해서는 포스팅을 한번 더 올리겠습니다.

<br>
<br>

## 1-7 관계와 조인의 이해

**관계(Relationshup)의 개념** 
- 엔티티의 인스턴스 사이의 논리적인 연관성 
- 엔티티의 정의, 속성 정의 및 관계 정의에 따라서도 다양하게 변환할 수 있음
- **관계를 맺는다는 의미는 부모의 식별자를 상속하고, 상속된 속성을 매핑키(조인키)로 활용 -> 부모, 자식을 연결**

<br>


**관계의 분류**

1) 존재 관계
   - 엔티티간의 상태를 의미
   - Ex. 사원 엔티티는 부서 엔티티에 소속

2) 행위 관계
   - 엔티티 간의 어떤 행위가 있는 것을 의미
   - Ex. 주문은 고객이 주문할 때 발생

<br>


**조인의 의미**
- 결국 데이터의 중복을 피하기 위해 테이블을 정규화에 의해 분리된다. 분리되면서 두 테이블은 서로 관계를 맺게 되고, 다시 이 테이블의 데이터를 동시에 ㅜㅊㄹ력하거나 관계가 있는 테이블을 참조학 ㅣ위해서는 데이터를 연결해야 하늗네 이 과정을 조인이라고 한다.ㄴ

<br>

**계층형 데이터 모델**
- **자기 자신끼리 관계가 발생.** 즉, 하나의 엔티티 내의 인스턴스끼리 계층 구조를 가지는 경우를 말함
- 계층 구조를 갖는 인스턴스끼리 연결하는 조인을 셀프조인이라고 함 (같은 테이블을 여러 번 조인)

<br>


**상호배타적 관계**
- 두 테이블 중 하나만 가능한 관계를 말함


주문 엔티티는 **개인 고객** 또는 **법인 고객**과만 연결될 수 있습니다. 따라서, 주문이 개인 고객과 연결되면 법인 고객과는 연결되지 않으며, 반대로 법인 고객과 연결되면 개인 고객과는 연결되지 않습니다.

| 주문번호 | 고객유형 | 고객번호 |
| -------- | -------- | -------- |
| 1        | 개인     | P001     |
| 2        | 법인     | C123     |
| 3        | 개인     | P002     |

#### 테이블 설명
- **고객유형**: 주문이 어떤 고객 유형(개인 또는 법인)에 해당하는지를 나타냅니다.
- **고객번호**: 해당 고객의 고유 번호를 의미합니다. 개인 고객의 경우 `P`로 시작하고, 법인 고객의 경우 `C`로 시작합니다.

이 테이블에서 주문번호 1번과 3번은 개인 고객과 연결되어 있으며, 주문번호 2번은 법인 고객과 연결되어 있습니다. 주문번호 1번이 개인 고객과 연결되었기 때문에 법인 고객과는 연결될 수 없습니다. 이와 같이 상호배타적 관계가 유지됩니다.

<br>
<br>

## 1-8 모델이 표현하는 트랜잭션의 이해

**트랜잭션 이란?**
- 하나의 연속적인 업무 단위를 말함
- 트랜잭션에 의한 관계는 필수적인 관계 형태를 가짐
- 하나의 트랜잭션에는 여러 SELECT, INSERT, DELETE, UPDATE 등이 포함될 수 있음

    EX. 계좌이체
    A 고객이 B 고객에게 100만원을 이체한다고 가정하자.
    - SETP01 : A 고객의 잔액이 100만원 이상인지 확인 
    - SETP02 : 이상이면, A 고객 잔액을 -100 UPDATE
    - SETP03 : B 고객 잔액에 + 100 UPDATE

    - 이때 2번과 3번 과정이 동시에 수행되어야 한다.
    - 즉, 모두 성공하거나 모두 취소돼야 함 (All or Noting) : 이런 특성을 갖는 연속적인 업무 단위를 트랜잭션이라고 한다.

**주의할 점**
1. A 고객 잔액 차감과 B 고객 잔액 가산이 서로 독립적으로 발생하면 안됨
   - 각각의 INSERT 문으로 개발하면 안됨
2. 부분 COMMIT 불가
   - 동시 COMMTI 또는 ROLLBACK 처리

<br>

**필수적, 선택적 관계와 ERD**
- 두 엔티티의 관계가 서로 필수적일 때 하나의 트랜잭션을 형성
- 두 엔티티가 서로 독립적 수행이 가능하다면 선택적 관계로 표현

<br>


**IE 표기법**
- 원을 사용하여 필수적 관계와 선택적 관계를 구분
- 필수적 관계에는 원을 그리지 않는다.
- 선택적 관계에는 관계선 끝에 원을 그린다.


**바커 표기법**
- 실선과 점선으로 구분
- 필수적 관계는 관계선을 실선으로 표기
- 선택적 관계는 관계선을 점선으로 표기

<br>


## 1-9 NULL 속성의 이해

**NULL 이란?**
- DBMS에서 아직 정해지지 않은 값을 의미한다.
- 0 과 빈 문자열("")과는 다른 개념
- 모델 설계 시 각 컬럼별로 NULL을 허용할 지를 결정 (Nullalbe Column)

<br>

**NULL의 특성**
1. NULL을 포함한 연산 결과는 항상 NULL

2. 집계함수는 NULL을 제외한 연산 결과 리턴
- sum, avg, min, max 등의 함수는 항상 NULL을 무시한다.

<br>

**NULL의 ERD 표기법**
- IE 표기법에서는 NULL 허용여부를 알 수 없음
- 바커 표기법에서는 속성 앞에 동그라미가 NULL 허용 속성을 의미함

<br>
<br>

## 1-10 본질 식별자

**식별자 구분 (대체 여부에 따른)**
1) 본질 식별자
   - 업무에 의해 만들어지는 식별자 (꼭 필요한 식별자)

2) 인조 식별자 
    - 인위적으로 만들어지는 식별자 (꼭 필요하지 않지만 관리의 필요성 등의 이유로 인위적으로 만들어진 식별자)
    - 본질 식별자가 복잡한 구성을 가질때 인위적으로 생성
    - 주로 각 행을 구분하기 위한 기본키로 사용되며 자동으로 증가하는 일련번호 같은 형태

<br>

**인조식별자의 단점**
1. 중복 데이터 발생 가능성 -> 데이터 품질 저하
2. 불필요한 인덱스 생성 -> 저장공간 낭비 및 DML 성능 저하

인덱스는 원래 조회 성능을 향상시키기 위한 객체이며, 인덱스는 DML(INSERT/UPDATE/DELETE)시 INDEX SPLIT 현상으로 인해 성능이 저한된다.